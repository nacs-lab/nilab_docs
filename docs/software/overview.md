# Software Overview

There are many different pieces of software that come together to run all pieces of the computer control system. We first provide an overview of what are all the pieces of software that are needed and list the repositories that one needs to access to acquire and review the source code. We go from the top-down for this overview. 

- **MATLAB Frontend**: The frontend is written in MATLAB and predominantly lives in *two* repositories. The shared code that is in principle usable by all experiments is located in the repository [`libnacs-matlab`](https://github.com/nacs-lab/libnacs-matlab). This shared code is a submodule for the main experimental control frontend code that is located in the repository [`experiment-control`](https://git.yuyichao.com/nigrp/experiment-control). Note that the shared code is hosted by `github`, while the actual experimental control code that contains the sequences and scans we run is hosted by `gitlab` on the private server of former graduate student Yichao Yu. 

- **Python interface to `libnacs`**: The MATLAB primary communicates with our **compiled** C++ code via the Python repository [`python-libnacs`](https://github.com/nacs-lab/python-libnacs). The code in this repository is rather limited and mainly wraps the functions that are exposed from the C++ layer. 
;
- **C++ library codebase**: The C++ codebase is known as [`libnacs`](https://github.com/nacs-lab/libnacs), and contains nearly all the C++ code on our experiment. This means it is used in multiple locations and serves many functions. On the experimental computer side, `libnacs` contains functions to compile a sequence as well as device-specific classes that are responsible for executing the sequence from the experimental computer side. These are client classes that ultimately send commands across a network. It also contains many utilities like functions covering memory and system management to networking tools, so it is also a helper library for other repositories including [`nacs-spcm`](https://github.com/nacs-lab/nacs-spcm) and [`molecube`](https://github.com/nacs-lab/molecube).

- **FPGA server**: The server code that runs on the FPGA is known as [`molecube`](https://github.com/nacs-lab/molecube). Molecube is a server so it responds to requests sent over a network either to provide simple pieces of information (such as the current status of the DDS and TTL channels) or it will run sequences on demand. Molecube communicates with the FPGA via reading and writing to a special memory address specified in the hardware configuration. This read and write occurs through the [`knacs`](https://github.com/nacs-lab/knacs) kernel driver. 

- **FPGA kernel driver**: The FPGA kernel driver handles the interface between the software running on the FPGA ([`molecube`](https://github.com/nacs-lab/molecube)) and the hardware, which has been configured according to the source code in [`molecube-hw`](https://github.com/nacs-lab/molecube-hw). The kernel driver has simple code to memory map the address of the main AXI bus used to communicate with the hardware.

- **FPGA hardware "code"**: The source FPGA hardware code, mostly written in SystemVerilog, is located in [`molecube-hw`](https://github.com/nacs-lab/molecube-hw). This code needs to be synthesized and implemented in Vivado, where the final product is a hardware configuration bit file. This hardware code is responsible for implementing commands with FPGA clock-cycle precision timing. These commands are responsible for programming the Analog Devices DDS chips and for adjusting the TTL outputs. 

- **AWG server code**: The AWG card is a PCIe card which is hosted on a separate computer. The AWG code located in [`nacs-spcm`](https://github.com/nacs-lab/nacs-spcm) contains a server which can respond to client requests such as running a sequence. It also contains code that interfaces with the Spectrum Instrumentation provided kernel driver to produce physical output on the card.